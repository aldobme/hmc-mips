#summary Detailed specifications for the MIPS memory system

= Introduction =

This specifies the memory subsystem, including the data and instruction cache, main memory, and the cache controller.

= Specifications =

== Overview ==

The memory subsystem is composed of the following subunits:

  * Two identical 4kB caches, one for data and one for instructions.
  * A cache controller, to interface the process with the cache and main memory.
  * A write buffer to reduce number of stalls when writing to main memory.
  * The main system memory.

A memory read or write is selected and started, via the cache controller, with the rwb (read/write bar) bit and en (enable) bit, respectively.  The cache controller signals a completed operation by asserting the done bit.  The interface to external memory is similar, where the cache controller expects external memory to haverwb, en, and done bits.  

== Interface ==

Most of the subcomponents interface using:

adr (address)
data (bi-direction data)
byteen (a byte mask for writing data less than a word in length)
rwb (read/write bar.  0 = write, 1 = read)
en (enable read/write)
done (signifies that memory operation is complete)

We'll call the module requesting a memory operation the _master_ and the module executing the operation the _slave_.  For example, normally the mips processor is the master and the cache the slave.  When a cache is writing to the write buffer, the cache is the master and the write buffer is the slave.

When the slaves input pins (adr, data if necessary, rwb, etc..) are valid, the master asserts enable.  Enable must be asserted for the entire duration of the operation (Todo: this may no longer be true. check this).  The slave will execute the operation and after completion, when the output pins have valid data, the slave asserts done.  There will always be at least a one cycle latency between the master asserting enable and the slave asserting done, except between the nips processor and the cache (for reading).  This is to complete a valid cached memory read within one cycle.

== Cache Controller ==

The cache controller interfaces the processor, cache, and main memory.  Additionally, it handles operations such as cache swapping.  The interface is as follows (controller's point of view):
{{{
input clk, reset,
input [31:0] pcF,
output [31:0] instrF,
input enF,
output instrackF,
                       
input [29:0] adrM, 
input [31:0] writedataM,
input [3:0] byteenM,
output [31:0] readdataM,
input memwriteM, enM,
output dataackM,
                       
input swc
}}}

Note that since an uncached address will retrieve or write to memory every time enable is asserted (and the previous option was completed), it is necessary for the data and instruction caches to both have enable inputs, so if the processor is stalling it won't keep repeating the memory operation.

Since the main memory only has one data and address bus, the cache controller is responsible for multiplexing between read/writes from the two caches and writes from the write buffer.  The cache controller will wait until the current memory operation is complete and start new ones with the following precedence:
  #  Write buffer write
  #  Data cache read
  #  Instruction cache read
The precedence is implemented using combinational logic and a multiplexer.  The data cache (or instruction cache if swapped) is connected directly to the write buffer if it requests a memory write.

If a data memory write occurs at the same time as an instruction memory read, the instruction memory read will occur first.  This is due to latency of writing to the write buffer and then the write buffer writing to memory.  This cycle latency may be improved in the future.
  
== Cache ==

There will be two identical caches, one for instructions and one for data.  Each cache will be 4kB in size and synchronous.  The cache will be of the following type:

  * _Write-through_: When data is written to an address, it is written immediately to memory as well as the cached.  The cache never has an newer copy of data than main memory.
  * _Write buffer_: To improve performance, so the CPU does not stall for the entire memory write latency, a FIFO (first-in first-out) write buffer is used.  Once the write buffer is full, the CPU must stall.
  * _Direct-mapped_: The lower bits (how many bits?) of the memory address will be used as the tag in the cache memory.
  * _Physically addressed_: The memory address the cache uses is based upon the physical address, the actual address in RAM, not a program address which is translated.
  * Support cache bypassing (via upper bits of memory address).  This is explained in the memory map below.
  * Support cache swapping (using the swc bit available in the status register).  This swaps the instruction and data cache so that the instruction cache can be invalidated.

Since each cache is 4kB and a word (32-bit) is 4 bytes, each cache can hold 1024 words.  A tag must be associated with each word, representing the lower bits of the address. 1024 = 2^10, so each tag is 10-bits long.  The tag has to hold the upper bits of the address, and all addresses should word aligned, hence 32 - 10 - 2 = 20 bits.  Additionally, a "valid" bit must be associated with each tag.  The total width of each cache slot is then 20 + 1 + 32 = 53 bits.

Each cache communicates through the following interface (from the cache's pov):
{{{
input clk, reset,
input [29:0] adr,
inout [31:0] data,
input [3:0] byteen,
input rwb, en,
output done,
             
output [29:0] memadr, 
inout  [31:0] memdata,
output [3:0] membyteen,
output memrwb,
output memen,
input memdone
}}}

The cache is synchronous with the processor and attempts to read a cache location within one clock cycle.  So, the cache will respond exactly as the E85 instruction and data memory did, for valid cached memory locations.  In this case, corresponding done signals will be asserted.  When a memory location is not in the cache, the done signal is not asserted.  The hazard unit of the cpu stalls, while the cpu waits a prefixed amount of time before reading in the result from main memory. 

When a word write is requested to an address that is cachable, but not currently in the cache, data is written to both the cache and to the write buffer.  When a half-word or byte address write is requested, it is sent directly to the write buffer, and invalidates the cache location, as noted above.  Hence, a store other than word length will never write to the cache, just invalidate.  This is primarily to retain compatibility with R2000 MIPS processors, to allow invalidation of cache lines.

==Write Buffer==

The write buffer is a four entry deep (not including data currently being written), as suggested by See MIPS Run, FIFO buffer.  Data can not be read from main memory until after the write buffer is empty, so a cache read miss directly after a memory write will stall the cpu until the write is complete.  In addition to storing the address and data for a write, the write buffer must also store the byteen byte mask, to support storing to half-word and byte memory locations.

The interface is:
{{{
input clk, reset,
input [29:0] adr,
input [31:0] data,
input [3:0] byteen,
input en,
output done,
                   
output reg [29:0] memadr,
output reg [31:0] memdata,
output reg [3:0] membyteen,
output reg memen,
input memdone
}}}


== Main Memory ==

The memory subsystem expects a single main memory interface.  The exact timings of the main memory are very flexible.  The main memory should expect an EN (enable) input when the cache system requests a read/write.  Once the main memory has performed the operation, and driven any necessary output ports with the correct value, it asserts done.

The interface from the main memory view is:

{{{
input clk, reset,
input [29:0] adr,
inout [31:0] data,
input [3:0] byteen,
input rwb, en,
output reg done
}}}

If the memory does not have these specifications, then a memory controller will need to be implemented to interface the cache system with the RAM.


=Memory Maps=

For simplicity, data and program memory are mapped the same.  Note that the program memory and data memory share identical physical addresses.  No mechanism is in place to protect program memory from accidental overwriting. 

  * kseg0 (cached program/data memory): 0x8000 0000 - 0x9FFF FFFF
  * kseg1 (uncached program/data memory):  0xA000 0000 - 0xBFFF FFFF

Hence, if the 3rd most significant bit of the address is high, memory is cached, otherwise it bypasses the cache.  The address is physically mapped by removing the top three bits.

= Programming Guidelines =

== Startup Procedures ==
The processor starts from 0xBFC0 0000 (508MB physically mapped;kseg1/uncached).  Since the cache will be full of garbage when the CPU starts, the cache must be initialized before use.  Entries in both I- and D-cache must be invalidated, by writing half-word or byte values to unused memory locations for all cache lines.  This can be accomplished using the algorithm outlined below:

== Cache Invalidation Procedures ==
Cache regions can be invalidated using: