#summary Detailed specifications for the MIPS memory system

= Introduction =

This specifies the memory subsystem, including the data and instruction cache, main memory, and the cache controller.

= Specifications =

== Overview ==

The memory subsystem is composed of the following subunits:

  * Two identical 1kB caches, one for data and one for instructions.
  * A cache controller, to interface the process with the cache and main memory.
  * A write buffer to reduce number of stalls when writing to main memory.
  * A memsys controller which contains the above plus mechanisms to multiplex data between the above components, the processor, and external memory.


A block diagram of this is shown below:

http://hmc-mips.googlecode.com/svn/trunk/images/mem.gif

== Interface ==

Most of the subcomponents' interfaces include:

adr (address)
data (bi-direction data)
byteen (a byte mask for writing data less than a word in length)
rwb (read/write bar.  0 = write, 1 = read)
en (enable read/write)
done (signifies that memory operation is complete)

We'll call the module requesting a memory operation the _master_ and the module executing the operation the _slave_.  For example, normally the mips processor is the master and the cache the slave.  When a cache is writing to the write buffer, the cache is the master and the write buffer is the slave.

When the slaves input pins (adr, data if necessary, rwb, etc..) are valid, the master asserts enable.  Enable must be asserted for the entire duration of the operation.  The slave will execute the operation and after completion, when the output pins have valid data, the slave asserts done.  There will always be at least a one cycle latency between the master asserting enable and the slave asserting done, except between the nips processor and the cache (for reading).  This is to complete a valid cached memory read within one cycle.

== Memsys ==

The MIPS memory system (memsys) interfaces the processor, cache, and main memory.  Additionally, it handles operations such as cache swapping.  Memsys is composed of a memsys controller, the two caches, and the write buffer.  The interface is as follows (memsys's point of view):
{{{
input ph1, ph2, reset,
input [31:2] pcF,
output [31:0] instrF,
input reF,
output instrackF,
                       
input [29:0] adrM, 
input [31:0] writedataM,
input [3:0] byteenM,
output [31:0] readdataM,
input memwriteM, reM,
output dataackM,
                       
input swc,
                       
output [26:0] memadr,
inout [31:0] memdata,
output [3:0] membyteen,
output memrwb,
output memen,
input memdone
}}}

Note that since an uncached address will retrieve or write to memory every time enable is asserted (and the previous option was completed), it is necessary for the data and instruction caches to have enable inputs, so if the processor is stalling it won't keep repeating the memory operation.

Since the main memory only has one data and address bus, the memsys is responsible for multiplexing between read/writes from the two caches and writes from the write buffer.  The cache controller will wait until the current memory operation is complete and start new ones with the following precedence:
  #  Write buffer write
  #  Data cache read
  #  Instruction cache read
The precedence is implemented using combinational logic and a multiplexer.  The data cache (or instruction cache if swapped) is connected directly to the write buffer if it requests a memory write.  When a component is using the external memory, the memory and component are multiplexed directly together, so once the memory asserts done the component's memdone will be high.  After one cycle, memsys disconnects the component and the memory, and connects a low to the memdone input of the component.
  
== Cache ==

Both caches are identical, one for instructions and one for data.  Each cache will be 1kB in size and synchronous.  The cache will be of the following type:

  * _Write-through_: When data is written to an address, it is written immediately to memory as well as the cached.  The cache never has an newer copy of data than main memory.
  * _Write buffer_: To improve performance, so the CPU does not stall for the entire memory write latency, a FIFO (first-in first-out) write buffer is used.  Once the write buffer is full, the CPU must stall.
  * _Direct-mapped_: The lower bits (how many bits?) of the memory address will be used as the tag in the cache memory.
  * _Physically addressed_: The memory address the cache uses is based upon the physical address, the actual address in RAM, not a program address which is translated.
  * Support cache bypassing (via upper bits of memory address).  This is explained in the memory map below.
  * Support cache swapping (using the swc bit available in the status register).  This swaps the instruction and data cache so that the instruction cache can be invalidated.

Since each cache is 1kB and a word (32-bit) is 4 bytes, each cache can hold 256 words.  A tag must be associated with each word, representing the lower bits of the address. 256 = 2^8, so each tag is 8-bits long.  The tag data must hold the upper bits of the address, and all addresses should word aligned, hence 32 - 8 - 2 = 22 bits.  Additionally, a "valid" bit must be associated with each tag.  The total width of each cache slot is then 22 + 1 + 32 = 55 bits.  256*55 = 14080 or 1.7kB.  The cache slots are stored in a _cacheram_ module, and the controls are generated from a _cachecontroller_ module.

Each cache communicates through the following interface (from the cache's pov):
{{{
input clk, reset,
input [29:0] adr,
inout [31:0] data,
input [3:0] byteen,
input rwb, en,
output done,
             
output [29:0] memadr, 
inout  [31:0] memdata,
output [3:0] membyteen,
output memrwb,
output memen,
input memdone
}}}

The cache is synchronous with the processor and attempts to read a cache location within one clock cycle.  So, the cache will respond exactly as the E85 instruction and data memory did, for valid cached memory locations.  In this case, corresponding done signals will be asserted.  When a memory location is not in the cache, the done signal is not asserted.  The hazard unit of the cpu stalls, while the cpu waits a prefixed amount of time before reading in the result from main memory. 

When a word write is requested to an address that is cachable, but not currently in the cache, data is written to both the cache and to the write buffer.  When a half-word or byte address write is requested, it is sent directly to the write buffer, and invalidates the cache location, as noted above.  Hence, a store other than word length will never write to the cache, just invalidate.  This is primarily to retain compatibility with R2000 MIPS processors, to allow invalidation of cache lines.

If a cache is given an uncached address (to bypass the cache), it will not read or write from the cache slots, but instead read or write directly to memory or the write buffer, respectively.

==Write Buffer==

The write buffer is a four entry deep (not including data currently being written), as suggested by See MIPS Run, FIFO buffer.  Data can not be read from main memory until after the write buffer is empty, so a cache read miss directly after a memory write will stall the cpu until the write is complete.  In addition to storing the address and data for a write, the write buffer must also store the byteen byte mask, to support storing to half-word and byte memory locations.

The interface is:
{{{
input clk, reset,
input [29:0] adr,
input [31:0] data,
input [3:0] byteen,
input en,
output done,
                   
output reg [29:0] memadr,
output reg [31:0] memdata,
output reg [3:0] membyteen,
output reg memen,
input memdone
}}}


== Main Memory ==

The memory subsystem expects a single main memory interface.  The exact timings of the main memory are very flexible.  The main memory should expect an EN (enable) input when the cache system requests a read/write.  Once the main memory has performed the operation, and driven any necessary output ports with the correct value, it asserts done.

The interface from the main memory's view is:

{{{
input ph1, ph2,
input [31:0] adr,
inout [31:0] data,
input [3:0] byteen,
input rwb, en,
output done)
}}}

If the memory does not have these specifications, then a memory controller will need to be implemented to interface the cache system with the RAM.  On the test implementation used for simulation, a reset pin was added to reset the state machine used to generate cycle latency.  Done can be asserted in as short as the same cycle, so the memory should not drive done high until it truly is.  Note that there are only 27 address bits bits from memsys, so 3 MSB's and 2 LSB's (since word addressed) of the external memory's address are driven low.


=Memory Maps=

For simplicity, data and program memory are mapped the same.  Note that the program memory and data memory share identical physical addresses.  No mechanism is in place to protect program memory from accidental overwriting. 

  * kseg0 (cached program/data memory): 0x8000 0000 - 0x9FFF FFFF
  * kseg1 (uncached program/data memory):  0xA000 0000 - 0xBFFF FFFF

In practice, the cache only checks if the 1st and 3rd most significant bit of the address is high to bypass the cache, otherwise the data is cached.  The address is physically mapped by removing the top three bits.

= Programming Guidelines =

== Startup Procedures ==
The processor starts from 0xBFC0 0000 (508MB physically mapped;kseg1/uncached).  Since the cache will be full of garbage when the CPU starts, the cache must be initialized before use.  Entries in both I- and D-cache must be invalidated, by writing half-word or byte values to unused memory locations for all cache lines.  After invalidation, the I- and D-cache can be used.  This can be accomplished using the algorithm outlined below:

  # Start in an uncached memory region
  # Set swc high in the status register to swap the cache (instruction cache is now the data cache)
  # For each cache line, invalidate by writing a byte or half-word value
  # Set swc low to swap instruction and data cache to normal arrangement
  # Repeat step 3
  # Jump to a cached instruction address

The following code will do this:

{{{
  // swap
  asm("swapon: addi  $9, $0, 1;
      sll $9,$9,17
      mtc0  $9, $12;
      nop;
      nop;
      nop");
  
  // Invalidate entire instruction cache
  asm("addi $10, $0, 256;
       addi $11, $0, 0x400;
       loop1:
       sb $0,0($11);
       addi $11,$11,4;
       addi $10,$10,-1;
       bnez $10,loop1");

  // unswap
  asm("swapoff: addi  $9, $0, 0;
      mtc0  $9, $12;
      nop;
      nop;
      nop");

  // Invalidate entire data cache
  asm("addi $10, $0, 256;
       addi $11, $0, 0x400;
       loop2:
       sb $0,0($11);
       addi $11,$11,4;
       addi $10,$10,-1;
       bnez $10,loop2");

}}}

After invalidating the cache, the bootloader should jump to a cached instruction address.