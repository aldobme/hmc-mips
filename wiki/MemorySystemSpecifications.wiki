#summary Detailed specifications for the MIPS memory system

= Introduction =

This specifies the memory subsystem, including the data and instruction cache, write buffer, external memory interface, and the memory system controller.

= Specifications =

== Overview ==

The memory and cache system is composed of the following modules:

  * Two identical 512 byte caches: one for data and one for instructions. 
  * A write buffer to reduce number of stalls when writing to main memory. 
  * A memsys controller which multiplexes data between the above modules, processor, and external memory. 

A block diagram of this is shown below:

http://hmc-mips.googlecode.com/svn/trunk/images/mem.gif

== Memory Interface Conventions ==

All of the primary memory and cache system modules follow a common interface convention for control signals and address/data buses.  The interface convention includes: 

  * adr: word address 
  * data: bi-direction data 
  * byteen: byte mask for writing data less than a word in length 
  * rwb: read/write bar, 0 = write, 1 = read 
  * en: enable read/write 
  * done: asserted when memory operation is complete

Most of the modules include the interface convention twice, one for requests from "lower" modules to the module and one for requests from the module to a "higher" module.  "Lower" and "higher" modules refer to the position of the module within the memory hierarchy shown below.  For example, from the write buffer's perspective, the "lower" module is the caches and the "higher" module is external memory.

http://hmc-mips.googlecode.com/svn/trunk/images/memhier.gif

We'll call the "lower" module requesting a memory operation the master and the current module executing the operation the slave.  When the slave's input pins (adr, data, rwb, etc..) from the master are valid, the master asserts en.  En must be asserted for the entire duration of the operation. The slave will execute the operation until completion, where it will drive necessary pins to the master and assert done. There will always be at least a one cycle latency between the master asserting en and the slave asserting done, except between the MIPS processor/cache interface (for reading) and the external memory interface. 

All of the interfaces for primary modules are detailed below and are from the slave's point of view.


== Memsys ==

The MIPS memory system (memsys) interfaces the processor, cache, and main memory.  Additionally, it handles operations such as cache swapping.  Memsys is composed of a memsys controller, the two caches, and the write buffer.  The interface is as follows (memsys's point of view):
{{{
input ph1, ph2, reset,
input [31:2] pcF,
output [31:0] instrF,
input reF,
output instrackF,
                       
input [29:0] adrM, 
input [31:0] writedataM,
input [3:0] byteenM,
output [31:0] readdataM,
input memwriteM, reM,
output dataackM,
                       
input swc,
                       
output [26:0] memadr,
inout [31:0] memdata,
output [3:0] membyteen,
output memrwb,
output memen,
input memdone
}}}

Note that since an uncached address will retrieve or write to memory every time enable is asserted (and the previous option was completed), it is necessary for the data and instruction caches to have enable inputs, so if the processor is stalling it won't keep repeating the memory operation.

Since the main memory only has one data and address bus, the memsys is responsible for multiplexing between read/writes from the two caches and writes from the write buffer.  The cache controller will wait until the current memory operation is complete and start new ones with the following precedence:
  #  Write buffer write
  #  Data cache read
  #  Instruction cache read
The precedence is implemented using combinational logic and a multiplexer.  The data cache (or instruction cache if swapped) is connected directly to the write buffer if it requests a memory write.  When a component is using the external memory, the memory and component are multiplexed directly together, so once the memory asserts done the component's memdone will be high.  After one cycle, memsys disconnects the component and the memory, and connects a low to the memdone input of the component.
  
== Cache ==

Both caches are identical, one for instructions and one for data.  Each cache are 512 in size and synchronous.  The caches are of the following type:

  * _Write-through_: When data is written to an address, it is written immediately to memory as well as the cached.  The cache never has an newer copy of data than main memory.
  * _Write buffer_: To improve performance, so the CPU does not stall for the entire memory write latency, a FIFO (first-in first-out) write buffer is used.  Once the write buffer is full, the CPU must stall.
  * _Direct-mapped_: The lower seven bits of the memory address will be used as the tag in the cache memory.
  * _Physically addressed_: The memory address the cache uses is based upon the physical address, the actual address in RAM, not a program address which is translated.
  * Support cache bypassing (via upper bits of memory address).  This is explained in the memory map below.
  * Support cache swapping (using the swc bit available in the status register).  This swaps the instruction and data cache so that the instruction cache can be invalidated.

Since each cache is 1kB and a word (32-bit) is 4 bytes, each cache can hold 256 words.  A tag must be associated with each word, representing the lower bits of the address. 256 = 2^8, so each tag is 8-bits long.  The tag data must hold the upper bits of the address, and all addresses should word aligned, hence 32 - 8 - 2 = 22 bits.  Additionally, a "valid" bit must be associated with each tag.  The total width of each cache slot is then 22 + 1 + 32 = 55 bits.  256*55 = 14080 or 1.7kB.  The cache slots are stored in a _cacheram_ module, and the controls are generated from a _cachecontroller_ module.

Each cache communicates through the following interface (from the cache's pov):
{{{
input ph1, ph2, reset,
input [29:0] adr,
inout [31:0] data,
input [3:0] byteen,
input rwb, en,
output done,
             
output [26:0] memadr, 
inout  [31:0] memdata,
output [3:0] membyteen,
output memrwb,
output memen,
input memdone
}}}

The cache is synchronous with the processor and attempts to read a cache location within one clock cycle.  So, the cache will respond exactly as the E85 mips processor's instruction and data memory did, for valid cached memory locations.  In this case, corresponding done signals will be asserted.  When a memory location is not in the cache, the done signal is not asserted.  The hazard unit of the cpu stalls, while the cpu waits a prefixed amount of time before reading in the result from main memory. 

When a word write is requested to an address that is cachable, but not currently in the cache, data is written to both the cache and to the write buffer.  When a half-word or byte address write is requested, it is sent directly to the write buffer, and invalidates the cache location, as noted above.  Hence, a store other than word length will never write to the cache, just invalidate.  This is primarily to retain compatibility with R2000 MIPS processors, to allow invalidation of cache lines.

If a cache is given an uncached address (to bypass the cache), it will not read or write from the cache slots, but instead read or write directly to memory or the write buffer, respectively.

==Write Buffer==

The write buffer is a four entry deep (not including data currently being written), as suggested by See MIPS Run, FIFO buffer.  Data can not be read from main memory until after the write buffer is empty, so a cache read miss directly after a memory write will stall the cpu until the write is complete.  In addition to storing the address and data for a write, the write buffer must also store the byteen byte mask, to support storing to half-word and byte memory locations.

The interface is:
{{{
input ph1, ph2, reset,
input [26:0] adr,
input [31:0] data,
input [3:0] byteen,
input en,
output done,
                   
output [26:0] memadr,
output [31:0] memdata,
output [3:0] membyteen,
output memen,
input memdone
}}}


== Main Memory ==

The memory subsystem expects a single main memory interface.  The exact timings of the main memory are very flexible.  The main memory should expect an EN (enable) input when the cache system requests a read/write.  Once the main memory has performed the operation, and driven any necessary output ports with the correct value, it asserts done.

The interface from the main memory's view is:

{{{
input ph1, ph2,
input [31:0] adr,
inout [31:0] data,
input [3:0] byteen,
input rwb, en,
output done)
}}}

If the memory does not have these specifications, then a memory controller will need to be implemented to interface the cache system with the RAM.  On the test implementation used for simulation, a reset pin was added to reset the state machine used to generate cycle latency.  Done can be asserted in as short as the same cycle, so the memory should not drive done high until it truly is.  Note that there are only 27 address bits bits from memsys, so 3 MSB's and 2 LSB's (since word addressed) of the external memory's address are driven low.


=Memory Map=

For simplicity, data and program memory are mapped the same.  Note that the program memory and data memory share identical physical addresses.  No mechanism is in place to protect program memory from accidental overwriting. 

  * kseg0 (cached program/data memory): 0x8000 0000 - 0x9FFF FFFF
  * kseg1 (uncached program/data memory):  0xA000 0000 - 0xBFFF FFFF

In practice, the cache only checks if the 1st and 3rd most significant bit of the address is high to bypass the cache, otherwise the data is cached.  The address is physically mapped by removing the top three bits.

= Programming Guidelines =

== Startup Procedures ==
The processor starts from 0xBFC0 0000 (508MB physically mapped;kseg1/uncached).  Since the cache will be full of garbage when the CPU starts, the cache must be initialized before use.  Entries in both I- and D-cache must be invalidated, by writing half-word or byte values to unused memory locations for all cache lines.  After invalidation, the I- and D-cache can be used.  This can be accomplished using the algorithm outlined below:

  # Start in an uncached memory region
  # Set swc high in the status register to swap the cache (instruction cache is now the data cache)
  # For each cache line, invalidate by writing a byte or half-word value
  # Set swc low to swap instruction and data cache to normal arrangement
  # Repeat step 3
  # Jump to a cached instruction address

The following code will do this:

{{{
  // swap
  asm("swapon: addi  $9, $0, 1;
      sll $9,$9,17
      mtc0  $9, $12;
      nop;
      nop;
      nop");
  
  // Invalidate entire instruction cache
  asm("addi $10, $0, 256;
       addi $11, $0, 0x400;
       loop1:
       sb $0,0($11);
       addi $11,$11,4;
       addi $10,$10,-1;
       bnez $10,loop1");

  // unswap
  asm("swapoff: addi  $9, $0, 0;
      mtc0  $9, $12;
      nop;
      nop;
      nop");

  // Invalidate entire data cache
  asm("addi $10, $0, 256;
       addi $11, $0, 0x400;
       loop2:
       sb $0,0($11);
       addi $11,$11,4;
       addi $10,$10,-1;
       bnez $10,loop2");

}}}

After invalidating the cache, the bootloader should jump to a cached instruction address.  Such as 
{{{
asm("addi $8, $0, 116
     jr $8");
}}}
to jump to address 0x74 (this is outside of the range of the memory map listed above, but recall that in practice the cache only checks if the addressed should be bypassed).  _jr_ must be used so that the upper bits of the PC change (unlike _jmp_).  Also, the stack pointer should be initialized:
{{{
asm("li $sp,0x300");
}}}
which initializes to 0x300.


