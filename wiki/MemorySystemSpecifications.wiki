#summary Detailed specifications for the MIPS memory system

= Introduction =

This specifies the memory subsystem, including the data and instruction cache, main memory, and the cache controller.

== Overview ==

The memory subsystem is composed of the following subunits:

  * Two identical 4kB caches, one for data and one for instructions.
  * A cache controller, to interface the process with the cache and main memory.
  * A write buffer to reduce number of stalls when writing to main memory.
  * The main system memory.

A memory read or write is selected and started, via the cache controller, with the rwb (read/write bar) bit and en (enable) bit, respectively.  The cache controller signals a completed operation by asserting the done bit.  The interface to external memory is similar, where the cache controller expects external memory to haverwb, en, and done bits.  

NEED: block diagram... instruction/data reading same time.

== Cache Controller ==

The cache controller interfaces the processor, cache, and main memory.  Additionally, it handles operations such as cache swapping and coordination with the write buffer.  The interface is as follows (controller's point of view):
{{{
input clk, reset,
input [31:0] pcF,
output [31:0] instrF,
input enF,
output instrackF,
                       
input [29:0] adrM, 
input [31:0] writedataM,
input [3:0] byteenM,
output [31:0] readdataM,
input memwriteM, enM,
output dataackM,
                       
input swc
}}}

Note that since an uncached address will retrieve or write to memory every time enable is asserted (and the previous option was completed), it is necessary to for the data and instruction caches to both have enable inputs, so if the processor is stalling it won't keep repeating the memory operation.

Since the main memory only has one data and address bus, the cache controller is responsible for multiplexing between read/writes from the two caches and writes from the write buffer.  The cache controller will wait until the current memory operation is complete and start new ones with the following precedence:
  #  Write buffer write
  #  Data cache read
  #  Instruction cache read
The precedence is implemented using combinational logic and a multiplexer.
  
== Cache Specifications ==

There will be two identical caches, one for instructions and one for data.  Each cache will be 4kB in size and synchronous.  The cache will be of the following type:

  * _Write-through_: When data is written to an address, it is written immediately to memory as well as the cached.  The cache never has an newer copy of data than main memory.
  * _Write buffer_: To improve performance, so the CPU does not stall for the entire memory write latency, a FIFO (first-in first-out) write buffer is used.  Once the write buffer is full, the CPU must stall.
  * _Direct-mapped_: The lower bits (how many bits?) of the memory address will be used as the tag in the cache memory.
  * _Physically addressed_: The memory address the cache uses is based upon the physical address, the actual address in RAM, not a program address which is translated.
  * Support cache bypassing (via upper bits of memory address).  This is explained in the memory map below.
  * Support cache swapping (using the swc bit available in the status register).  This swaps the instruction and data cache so that the instruction cache can be invalidated.

Since each cache is 4kB and a word (32-bit) is 4 bytes, each cache can hold 1024 words.  A tag must be associated with each word, representing the lower bits of the address. 1024 = 2^10, so each tag is 10-bits long.  The tag has to hold the upper bits of the address, and all addresses should word aligned, hence 32 - 10 - 2 = 20 bits.  Additionally, a "valid" bit must be associated with each tag.  The total width of each cache slot is then 20 + 1 + 32 = 53 bits.

Each cache communicates through the following interface (from the cache's pov):
{{{
input clk, reset,
input [29:0] adr,
inout [31:0] data,
input [3:0] byteen,
input rwb, en,
output done,
output [29:0] memadr, 
inout [31:0] memdata,
output [3:0] membyteen,
output memrwb, memen,
input memdone
}}}

The cache is synchronous with the processor and attempts to read a cache location within one clock cycle.  So, the cache will respond exactly as the E85 instruction and data memory did, for valid cached memory locations.  In this case, corresponding done signals will be asserted.  When a memory location is not in the cache, the done signal is not asserted.  The hazard unit of thecpu stalls, while the cpu waits a prefixed amount of time before reading in the result from main memory. 

When a word write is requested to an address that is cachable, but not currently in the cache, the cache is updated and the write is added to the write buffer.  When a half-word or byte address write is requested, it is sent directly to the write buffer, and invalidates the cache location, as noted above.  Note that the cache does not have abyteen mask as above, but instead has a single invalidate bit, because a half-word or byte store will never modify cached data.  This is primarily to retain compatibility with R2000 MIPS processors.

== Main Memory ==

The memory subsystem expects a single main memory interface.  The exact timings of the main memory are very flexible.  The main memory should expect an EN (enable) input when the cache system requests a read/write.  Once the main memory has performed the operation, and driven any necessary output ports with the correct value, it asserts done.

The interface from the main memory view is:

{{{
input clk, reset,
input [29:0] adr,
inout [31:0] data,
input [3:0] byteen,
input rwb, en,
output reg done
}}}

If the memory does not have these specifications, then a memory controller will need to be implemented to interface the cache system with the RAM.

==Write Buffer==

The write buffer is a four entry deep (as suggested by See MIPS Run) FIFO buffer.  Data can not be read from main memory until after the write buffer is empty, so a cache read miss directly after a memory write will stall thecpu until the write is complete.  In addition to storing the address and data for a write, the write buffer must also store the byteen byte mask, to support storing to half-word and byte memory locations.

The interface is:
{{{
input clk, reset,
input [29:0] adr,
input [31:0] data,
input [3:0] byteen,
input en, output done,
output reg [29:0] memadr,
output reg [31:0] memdata,
output reg [3:0] membyteen,
output reg memen,
input memdone
}}}

=Memory Maps=

For simplicity, data memory is mapped identical to program memory.  Note that the program memory and data memory share identical physical addresses.  No mechanism is in place to protect program memory from accidental overwriting. 

  * kseg0 (cached program/data memory): 0x8000 0000 - 0x9FFF FFFF
  * kseg1 (uncached program/data memory):  0x0000 0000 - 0xBFFF FFFF

Hence, if the msb of the address is high memory is cached, otherwise is bypasses the cache.

= Programming Guidelines =

== Startup Procedures ==
Since the cache will be full of garbage when the CPU starts, the cache must be initialized before use.  Entries in both I- and D-cache must be invalidated, by writing half-word or byte values to unused memory locations for all cache lines.  This can be accomplished using the algorithm outlined below:

(do we even need to write?  Or just read from unused memory locations?  Check this from book)

== Cache Invalidation Procedures ==

= Test Plan =



somewhere in here:  A buffer write doesn't immediately cause everything to stop... there is a few cycle delay before it actually take priority in memory.